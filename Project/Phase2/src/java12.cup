import java_cup.runtime.*;


/* August 1999 - modified by Gerwin Klein <lsf@jflex.de>
                 to interface with JFlex scanners,
                 allows empty semicolon in class decls.
  
  changed productions:

  class_member_declaration ::=
	  	field_declaration
  	|	method_declaration
    [..]
  	|	interface_declaration
    | SEMICOLON
  	;

  interface_member_declaration ::=
  		constant_declaration
	  |	abstract_method_declaration
  	|	class_declaration
  	|	interface_declaration
    | SEMICOLON
	  ;

*/


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal SEMICOLON; // ;
terminal INT; // int
terminal DOUBLE; // double
terminal BOOLEAN; // bool
terminal STRING; // string
terminal IDENTIFIER; // ident
terminal LEFTBRACK, RIGHTBRACK; // []
terminal COMMA; // ,
terminal CLASS; // class
terminal EXTENDS; // extends
terminal IMPLEMENTS; // interface
terminal PRIVATE, PROTECTED, PUBLIC; // private, protected, public
terminal INTERFACE; // interface
terminal VOID; // void
terminal IF, ELSE; // if, else
terminal WHILE; // while
terminal FOR; // for
terminal RETURN; // return
terminal BREAK; // break
terminal CONTINUE; // continue
terminal PRINT; // print
terminal ASSIGN; // =
terminal THIS; // this
terminal LEFTPAREN, RIGHTPAREN; // ()
terminal PLUS, MINUS, MULT, DIV; // +, -, *, /
terminal MOD, LT, LTEQ; // %, <, <=
terminal GT, GTEQ, EQEQ, NOTEQ; // >, >=, ==, !=
terminal ANDAND, OROR, NOT, READINTEGER; // &&, ||, !, ReadInteger
terminal READLINE, NEW, NEWARRAY; // readLine, new, NewArray
terminal ITOD, DTOI, ITON, BTOI; // itod, dtoi, itob, btoi
terminal DOT; // .
terminal INTCONSTANT, DOUBLECONSTANT, BOOLCONSTANT; // intConstant, doubleConstant, boolConstant
terminal STRINGCONSTANT, NULL; // stringConstant, null

non terminal Program;
non terminal Structure;
non terminal Decl;
non terminal VariableDecl;
non terminal Variable;
non terminal Type;
non terminal FunctionDecl;
non terminal Formals;
non terminal ClassDecl;
non terminal ExtendDecl;
non terminal ImplementDecl;
non terminal Field;
non terminal AccessMode;
non terminal InterfaceDecl;
non terminal Prototype;
non terminal StmtBlock;
non terminal VariableUsage;
non terminal Stmt;
non terminal IfStmt;
non terminal ElseStmt;
non terminal WhileStmt;
non terminal ForStmt;
non terminal ReturnStmt;
non terminal BreakStmt;
non terminal ContinueStmt;
non terminal PrintStmt;
non terminal Expr;
non terminal LValue;
non terminal Call;
non terminal Actuals;
non terminal Constant;

start with Program;

Program ::= Structure
	;
Structure ::= Decl Structure | Decl
	;
Decl ::= VariableDecl | FunctionDecl | ClassDecl | InterfaceDecl
	;
VariableDecl ::= Variable SEMICOLON
	;
Variable ::= Type IDENTIFIER
	;
Type ::= INT | DOUBLE | BOOL | STRING | IDENTIFIER | Type LEFTBRACK RIGHTBRACK
	;
FunctionDecl ::= Type IDENTIFIER LEFTPAREN Formals RIGHTPAREN StmtBlock | VOID IDENTIFIER LEFTPAREN Formals RIGHTPAREN StmtBlock
	;
Formals ::= Variable COMMA Formals | Variable COMMA 
	;
ClassDecl ::= CLASS IDENTIFIER ExtendDecl ImplementDecl LEFTBRACK Field RIGHTBRACK
	;
ExtendDecl ::= EXTENDS IDENTIFIER |
	;
ImplementDecl ::= IMPLEMENTS IDENTIFIER COMMA ImplementDecl |  
	;
Field ::= AccessMode VariableDecl Field | AccessMode FunctionDecl Field | 
	;
AccessMode ::= PRIVATE | PROTECTED | PUBLIC | 
	;
InterfaceDecl ::= INTERFACE IDENTIFIER LEFTBRACK Prototype RIGHTBRACK
	;
Prototype ::= Type IDENTIFIER LEFTPAREN Formals RIGHTBRACK SEMICOLON Prototype| VOID IDENTIFIER LEFTPAREN Formals RIGHTBRACK SEMICOLON Prototype |
	;
StmtBlock ::= LEFTBRACK VariableUsage RIGHTBRACK 
	;
VariableUsage ::= VariableDecl Stmt VariableUsage | VariableDecl VariableUsage | Stmt VariableUsage | 
	;
Stmt ::= Expr SEMICOLON | SEMICOLON | IfStmt | WhileStmt | ForStmt | BreakStmt | ContinueStmt | ReturnStmt | PrintStmt | StmtBlock
	;
IfStmt ::= IF LEFTPAREN Expr RIGHTPAREN Stmt ElseStmt 
	;
ElseStmt ::= ELSE Stmt | 
	;
WhileStmt ::= while LEFTPAREN Expr RIGHTPAREN Stmt
	;
ForStmt ::= for LEFTPAREN < Expr >;Expr;< Expr > RIGHTPAREN Stmt
	;
ReturnStmt ::= return < Expr >;
	;
BreakStmt ::= break;
	;
ContinueStmt ::= continue;
	;
PrintStmt ::= print (Expr+, );
	;
Expr ::= LValue = Expr | Constant | LValue | this | Call | (Expr) |
Expr + Expr | Expr − Expr | Expr ∗ Expr | Expr / Expr |
Expr % Expr | − Expr | Expr < Expr | Expr <= Expr |
Expr > Expr | Expr >= Expr | Expr == Expr | Expr! = Expr |
Expr && Expr | Expr || Expr | !Expr | ReadInteger() |
readLine() | new ident | NewArray(Expr, Type) |
itod(Expr) | dtoi(Expr) | itob(Expr) | btoi(Expr)
	;
LValue ::= ident | Expr . ident | Expr[Expr]
	;
Call ::= ident (Actuals) | Expr . ident (Actuals)
	;
Actuals ::= Expr+, | ϵ
	;
Constant ::= intConstant | doubleConstant | boolConstant | stringConstant | null
	;